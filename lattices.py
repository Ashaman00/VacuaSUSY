from fractions import Fraction
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from math import ceil, sqrt
import copy
from testFormula import *
from dualities import *


# Operations on tuples ##################################

def tmul(N, tup):
    return tuple(N * t for t in tup)


def tadd(tup1, tup2):
    assert len(tup1) == len(tup2)
    return tuple(t + s for (t, s) in zip(tup1, tup2))


def tmod(tup, n):
    return tuple(t % n for t in tup)


# Some utils ############################################

def remove_duplicate(li):
    res = []
    for elt in li:
        if elt not in res:
            res.append(elt)
    return res


def colinear(p1, p2):
    return p1[0] * p2[1] == p2[0] * p1[1]


def project(point, v1, v2, rescale=False):
    det = v1[0] * v2[1] - v2[0] * v1[1]
    x = (v2[1] * point[0] - v2[0] * point[1]) / det
    y = (-v1[1] * point[0] + v1[0] * point[1]) / det
    if rescale:
        x, y = x % 1, y % 1
    return (x, y)


# Comparisons will work for Fraction (or integer) periods points, not floats
class Lattice2D:
    def __init__(self, period1=(1, 0), period2=(0, 1)):
        if colinear(period1, period2):
            raise ValueError
        self.p1 = period1
        self.p2 = period2
        self.center = tmul(.5, tadd(self.p1, self.p2))
        self.points = set()

    def project_point(self, point, real_coord=True, rescale=True):
        '''Project the point on the base vectors of the lattice, and project it
        into the fundamental torus if rescale is True. If real_coord is False,
        the point is meant to be already defined relatively to the base periods
        '''
        if not real_coord:
            if rescale:
                return point[0] % 1, point[1] % 1
            return point
        return project(point, self.p1, self.p2, rescale)

    def add_point(self, point, real_coord=True, rescale=True):
        '''Add a point in the lattice. real_coord and rescale have the same
        meaning as in the project_point function. An exception is raised if
        rescale is False and the point is not in the torus.
        '''
        x = self.project_point(point, real_coord, rescale)
        if not rescale and not all(0 <= y <= 1 for y in x):
            raise ValueError
        self.points.add(x)

    def has_point(self, point, real_coord=True, rescale=True):
        '''Check whether a point is present in the lattice'''
        x = self.project_point(point, real_coord, rescale)
        if not rescale and not all(0 <= y <= 1 for y in x):
            raise ValueError
        return x in self.points

    def remove_point(self, point, real_coord=True, rescale=True):
        '''Remove a point from the lattice. An exception is
        raised if the point does not exist.
        '''
        x = self.project_point(point, real_coord, rescale)
        if not rescale and not all(0 <= y <= 1 for y in x):
            raise ValueError
        self.points.remove(x)

    def to_real_coords(self, c):
        '''Return the coordinates of a point defined
        relatively to the base vectors
        '''
        return (c[0] * self.p1[0] + c[1] * self.p2[0],
                c[0] * self.p1[1] + c[1] * self.p2[1])

    def sub_project(self, lat):
        '''Project all the points into the lattice lat, which must
        be a superlattice of self, otherwise an exception is raised
        '''
        if not self.is_sublattice(lat):
            raise ValueError
        (lat.addPoint(p) for p in self.points)
        return lat

    def plot(self, ax, sx, sy=-1, col_p='#4040FF', col_f='red', col_a='green'):
        '''Plot the lattice, with the points and the torus, plus the projection
        on the canonical torus generated by (0,1), (1,0)
        '''
        if sy == -1:
            sy = sx
        frame = [self.center[0] - sx / 2, self.center[0] + sx / 2,
                 self.center[1] - sy / 2, self.center[1] + sy / 2]

        def in_zone(p):
            return frame[0] <= p[0] <= frame[1] \
                and frame[2] <= p[1] <= frame[3]

        # set the size
        ax.axis(frame)
        ax.set_aspect(1.)

        # add the parallelogram and the fundamental torus
        ax.add_patch(Polygon([[0, 0], self.p1, tadd(
            self.p1, self.p2), self.p2], color=col_a, alpha=.3))
        ax.add_patch(
            Polygon([[0, 0], [0, 1], [1, 1], [1, 0]], 'black', fill=False))

        if len(self.points) == 0:
            return ax

        # add all the points
        res = set()
        unvisited = list(self.to_real_coords(p) for p in self.points)
        while len(unvisited) != 0:
            elt = np.array(unvisited.pop())
            direcs = [self.p1, self.p2, tmul(-1, self.p1), tmul(-1, self.p2)]
            elts = [tadd(elt, direc) for direc in direcs]
            for e in elts:
                e = (e[0], e[1])
                if in_zone(e) and e not in res:
                    res.add(e)
                    unvisited.append(e)

        # draw the points and enlighten the principal patterns
        ax.scatter(*list(zip(*res)), color=col_p)
        ax.scatter(*list(zip(*(self.to_real_coords(p)
                               for p in self.points))), color=col_f)
        ax.scatter(*list(zip(
            *(project(self.to_real_coords(p), (1, 0), (0, 1), True)
              for p in self.points))), s=14, c='black', marker='^', alpha=.7)
        return ax

    def get_superlattice(self, N, d, t):
        '''Return the superlattice associated with d and t'''
        assert N % d == 0 and 0 <= t < d
        return Lattice2D(self.to_real_coords((Fraction(d, N), Fraction(0))),
                         self.to_real_coords((Fraction(t, N), Fraction(1, d))))

    def fill_with_sublattice(self, N, d, t, fund=False):
        '''Add the points corresponding to the
        sublattice associated with d and t
        '''
        assert N % d == 0 and 0 <= t < d
        base1 = (Fraction(d, N), Fraction(0))
        base2 = (Fraction(t, N), Fraction(1, d))
        for k in range(N // d):
            for l in range(d):
                if not fund:
                    self.add_point(tadd(tmul(k, base1), tmul(l, base2)), False)
                else:
                    self.add_point(
                        tmod(tadd(tmul(k, base1), tmul(l, base2)), 1))

    def is_sublattice(l1, l2):
        '''Check wheter l2 is a sublattice of l1'''
        return all(project(p, l2.p1, l2.p2, True) == (0, 0)
                   for p in [l1.p1, l1.p2])

    def is_same_lattice(l1, l2):
        '''Check whether l1 and l2 are the same lattice'''
        return l1.is_sublattice(l2) and l2.is_sublattice(l1)

    def __eq__(self, other):
        '''Check whether self and other are the same lattice,
        with the same points added
        '''
        if not isinstance(other, self.__class__):
            return False
        if not self.is_same_lattice(other):
            return False
        tmp = Lattice2D(self.p1, self.p2)
        for p in other.points:
            tmp.add_point(other.to_real_coords(p), True)
        return tmp.points == self.points


# Solving the problem #####################################

# compute the lattice generated by (d, 0), (m, 0), (t, N/d) and (-n, N/m)
def real_period(N, m, n, d, t):
    x = gcds(d, m, (t * d + n * m) // gcds(d, m))
    u, v = bezout(m, d)
    a, b = tadd(tmul(u, (t, N // d)), tmul(v, (-n, N // m)))
    return Lattice2D((x, 0), (a % x, b))


def get_Ncover(N, m, n):
    assert N % m == 0 and 0 <= n < m
    return Lattice2D((m, 0), ((-n) % m, N // m))


def get_inequivalent_Ncovers(N, m, n, d, t, real=False):
    lattice = get_Ncover(N, m, n) if not real else real_period(N, m, n, d, t)
    lattice.fill_with_sublattice(N, d, t, True)
    point = (Fraction(d, N), Fraction(0))
    if d == N:
        point = (Fraction(t, N), Fraction(1, d))
    lattice.remove_point(point)
    seen = real_period(N, m, n, d, t)
    res = []
    for x in range(d):
        for y in range(N // d):
            p = tadd(point, (x, y))
            if seen.has_point(p):
                continue
            seen.add_point(p)
            lat = copy.deepcopy(lattice)
            lat.add_point(p)
            res.append(lat)

    return remove_duplicate(res)


# project the solution into the fundamental torus
def project_fund(lattice):
    res = Lattice2D()
    for p in lattice.points:
        res.add_point(lattice.to_real_coords(p))
    return res


def dual_lattice(lat, duality=Sduality):
    res = Lattice2D(duality.point(lat.p1), duality.point(lat.p2))
    for p in lat.points:
        res.add_point(duality.point(lat.to_real_coords(p)))
    return res


# Results #################################################

def print_inequivalent_solutions(N, m, n, d, t, real=False, title=True):
    lattices = get_inequivalent_Ncovers(N, m, n, d, t, real)
    c = len(lattices)
    if c > 3:
        sy = ceil(sqrt(c))
        sx = sy - 1 if sy * (sy - 1) >= c else sy
    else:
        sx, sy = 1, 3

    if title:
        plt.suptitle(f'$(SU({N})/\\mathbb{{Z}}_{m})_{n}$ with d={d}, t={t}',
                 fontsize=18)
    for i, lat in enumerate(lattices):
        ax = plt.subplot(sx, sy, i + 1)
        lat.plot(ax, N + 3)
    plt.tight_layout(pad=1)
    plt.subplots_adjust(top=0.9)
    plt.show()


def print_with_duality(N, m, n, d, t, dual=Sduality, real=False, title=True):
    res = get_inequivalent_Ncovers(N, m, n, d, t, real)
    res_dual = get_inequivalent_Ncovers(N, *dual.theory(N, m, n),
                                        *dual.sublattice(N, d, t), real)
    print(len(res), len(res) == len(res_dual) == e1e2(N, m, n, d, t))
    size = len(res)

    if title:
        plt.suptitle(dual.name +
                 f' of $(SU({N})/\\mathbb{{Z}}_{m})_{n}$ with d={d}, t={t}',
                 fontsize=18)

    for i, (lat, latd) in enumerate(zip(res, res_dual)):
        ax1 = plt.subplot(2, size, i + 1)
        ax2 = plt.subplot(2, size, size + i + 1)
        dual_lattice(lat, dual).plot(ax2, N + 4)
        latd.plot(ax1, N + 3)
    plt.tight_layout(pad=1)
    plt.subplots_adjust(top=0.9)
    plt.show()


def verifyTally(Nmax, dual=Sduality):
    ok = True
    for N, m, n in all_theories(Nmax):
        for d, t in all_sublattices(N):
            res = get_inequivalent_Ncovers(N, m, n, d, t)
            res_dual = get_inequivalent_Ncovers(N, *dual.theory(N, m, n),
                                                *dual.sublattice(N, d, t))
            real = real_period(N, m, n, d, t)
            nb = real.p1[0] * real.p2[1]  # area of the parallelogram
            if not len(res) == len(res_dual) == e1e2(N, m, n, d, t) == nb:
                print(f'Error at N={N}, m={m}, n={n}, d={d}, t={t}')
    if ok:
        print('No errors')


def verifyCommutation(Nmax, dual=Sduality):
    ok = True
    for N, m, n in all_theories(Nmax):
        for d, t in all_sublattices(N):
            fund_dual = Lattice2D()
            fund_dual.fill_with_sublattice(N, *dual.sublattice(N, d, t))
            for lat in get_inequivalent_Ncovers(N, m, n, d, t):
                if project_fund(dual_lattice(lat, dual)) != fund_dual:
                    print(f'Error at N={N}, m={m}, n={n}, d={d}, t={t}')
    if ok:
        print('No errors')


print_inequivalent_solutions(3, 3, 1, 3, 2, True, False)
# print_inequivalent_solutions(4, 4, 2, 4, 0, True)
# print_inequivalent_solutions(12, 4, 2, 2, 0, True)
# print_inequivalent_solutions(12, 4, 2, 2, 0)

# print_with_duality(3, 3, 1, 3, 2, real=True, title=False)
# print_with_duality(4, 4, 2, 4, 0)
# print_with_duality(4, 4, 2, 4, 0, Tduality)
# print_with_duality(12, 4, 2, 2, 0)

# verifyTally(10)
# verifyTally(10, Tduality)
# verifyCommutation(10)
# verifyCommutation(10, Tduality)
